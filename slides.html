<!DOCTYPE html>
<html>
  <head>
    <title>Reading &amp; Cleaning Data and Regular Expressions</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

	<center>
  <h2>
Reading & Cleaning Data<br/>
      Regular Expressions
      </h2>
</center>

<div style="padding-bottom: 70px">
<div style="float: left; valign: top; padding-left: 80px;">
Matt Espe <br/>
Postdoc<br/>
</div>
<div style="float: right; valign: top; padding-right: 30px; padding-bottom: 20px;">
Duncan Temple Lang <br/>
Director, Data Science Initiative<br/>
Professor, Statistics	<br/>    
</div>
</div>

### [https://github.com/dsidavis/data_cleaning_w_r](https://github.com/dsidavis/data_cleaning_w_r)

<div style="clear: both"/>

<!-- <hr width="50%"/> -->
<img src="http://dsi.ucdavis.edu/images/dsi_banner.png" width="30%" height="30%"></img>

---
layout: true
<img style="float: right" src="http://dsi.ucdavis.edu/images/dsi_brand_logo.png"></img>

---

# Goals

+ Process of cleaning data
+ Reading non-tabular data into R.

+ Intersection:  Regular Expressions
   + pattern matching and substitution in text

---

# Reading Data

---


# Cleaning Data

+ Cleaning data requires judgment and decision making in the presence of ambiguity.
  + You need to ask the owner and collector(s) of the data to explain possible issues.
  + You should explicitly record your decisions and actions (for you and others)
  + You should return to review your decisions and see how they affect conclusion

+ Cleaning requires thought about how the data collection could lead to errors.
   + Often general problems, but always possible context-specific issues.

+ Cleaning should exist as part of the data life cycle, not separate
from it.

---

See [Barley.md](Barley.md)

---

# The Data Life cycle

Is this how we use data?

<img src="linear.png" alt="USGS Data lifecycle" style="width: 800px;"/>

---

# Data Life cycle (cont.)

+ In most cases, this is a cycle, not linear. E.g., you use the data, find
issues, fix them, get more data, etc. 
  + Data created
  + Cleaned/processed 
  + "Used" in some way

+ What if the original data is changed after it is cleaned?

+ What if the end or intermediate use is in Excel/GoogleSheets/OpenRefine, etc.?

---
# Program defensively!

Don't assume:
+ The data will never change
+ You will forever remember what you were doing in this moment
+ Your assumptions are correct (e.g., you might need to go back and correct
  a bad "fix")
+ You understand perfectly how errors occurred

Aim to write software rather than scripts

---

# Writing a script vs. software

+ script: fixes instances, (maybe) specialized to the data, assumes the data are
static. Breaks if the data change, assumes a linear workflow.

```
> df[12, 3] = "Bob"
```
Why row 12? Why column 3? What if Dr. Smarty-pants inserts a new
column in position 1?

+ software: flexible to fix conditions, not specific instances. Data
can change without breaking script

```
> df$names[df$names == "bob"] = "Bob" 
```
Invariant to order of rows/columns. If the data are already corrected,
has no effect.

But writing software is more effort (higher cost), requires more thought.
---

# R Functions which use Regex

+ grep() and grepl()
+ gregexpr() and regexpr()
+ regmatches()
+ sub() and gsub()
+ strsplit()
+ agrep()
+ adist()

+ Others from stringr and stringi packages.
   + e.g. str_extract()


## Shell Commands

+ grep, egrep, ag
+ find
---

# Regex Elements

+ Literals

+ Wildcard Character  `.`

+ Character Classes

+ Negated Character Classes

+ Positional Matching - Anchors  (`^` and `$`)

+ Alternation

+ Case Insensitive matching

+ Word boundaries

+ Quantifiers

+ Grouping and Back-References ()

---
# Regex Extensions

  + Non-greedy Matching
      + Problems with greedy matching.
  	  + Common simple case, simple solution
	     + Anything except this character
	     + or any of these characters
      + *?

+ Positive Lookahead and Behind

+ Negative Lookahead and Behind

---
## Literals

Matches to the literal characters.

```
> strings = c("My dog is cool.", "My cat is cooler.")

> grep("dog", strings)
[1] 1

```

Special characters `.()[]\^$` have to be escaped with double `\`

```
> strings = c("This is a period: '.' ", "There is no period here")

> grep(".", strings)
[1] 1 2

> grep("\\.", strings)
[1] 1

```

---
					
## Wildcard Character  `.`

Matches **any** character.

```
> strings = c("cat", "hat", "bat", "4at", "Manhattan")

> grep(".at", strings)
[1] 1 2 3 4 5

```
Can be extremely useful, or create havoc. Use caution.

---
## Character Classes

Matches any character in a set of specified characters inside of `[]`.

```
> strings = c("cat", "hat", "bat", "4at", "Manhattan")

> grep("[bc]at", strings)
[1] 1 3

```

Shorthand for classes of characters, include:

+ numbers: `[0-9]` or `[[:digit:]]`
+ letters: `[A-z]` (all), `[A-Z]` (uppercase), `[a-z]` (lowercase),
`[[:alpha:]]`
+ Alphanumeric: `[[:alnum:]]`
+ space characters: `\t`, `\n`, `[[:space:]]`

```
> strings = c("Abc", "abc", "123", "Abc123")

> grep("[A-z]", strings) # Any alphabetic
[1] 1 2 4

> grep("[a-z]", strings) # Any lower-case alphabetic
[1] 1 2 4

> grep("[0-9]", strings) # Any digit
[1] 3 4

> grep("[A-z0-9]", strings) # Any alphanumeric
[1] 1 2 3 4
```

---
## Negated Character Classes

Uses `^` inside of `[]` to negate the match, i.e., match everything
except those characters.

```
> strings = c("Abc", "abc", "123", "Abc123")

> grep("[^A-z]", strings) # Contains non-alphabetic
[1] 3 4

> grep("[^a-z]", strings) # Contains non-lower case
[1] 1 3 4

> grep("[^0-9]", strings) # contains non-digits
[1] 3 4
```

---
## Positional Matching - Anchors  `^` `$`

Matches the beginning (`^`) or end (`$`) of the string. Used outside
of `[]`

```
> strings = c("cat", "bat", "check", "China")

> grep("^c", strings) #First character is "c"
[1] 1 3

> grep("t$", strings) # Last character is "t"
[1] 1 2

```

---

## Alternation

+ Matches either multiple single characters (can use more than two)
inside `[]`
+ Matches multiple patterns by using the `|` (called the "pipe", shift + key above
"Enter" key on US keyboards) outside of `[]` 

```
> strings = c("cat", "bat", "hat", "coat")

> grep("[cb]at", strings)
[1] 1 2

> grep("hat|coat", strings)
[1] 3 4
```

---
## Case Insensitive matching

Most regex functions have an option to `ignore.case`

```
> strings = c("Cat", "cat", "CAT", "bat", "Hat")

> grep("cat", strings, ignore.case = TRUE)
[1] 1 2 3
```
---
## Word boundaries

Useful when looking for a word that occurs as a pattern inside other
words. Specified with `\\b` (either end of word), `\\<` (beginning of
word), or `\\>` (end of word)

```
> strings = c("This", "is", "Mississippi.", "This is Mississippi.")
> grep("is", strings)
[1] 1 2 3 4

> grep("is\\>", strings)
[1] 1 2 4

> grep("\\bis\\b", strings)
[1] 2 4
```

---
## Quantifiers

+ Optional pattern: `?` character can occur 0 or 1 times
```
> strings = c("abc", "ac", "abbc")
> grep("ab?c", strings)
[1] 1 2
```
+ Zero or more  *
```
> grep("ab*c", strings)
[1] 1 2 3
```
+ One or more  \+
```
> grep("ab+c", strings)
[1] 1 3
```
---
## Quantifiers (cont.)

+ m or more   `{m,}`
```
> grep("ab{2,}c", strings)
[1] 3
```
+ n or fewer   `{,n}`
```
> grep("ab{2,}c", strings)
[1] 1 2 3
```
+ between m and n  `{m,n}`
```
> grep("ab{1,2}c", strings)
[1] 1 3
```

---
## Grouping and Back-References ()

+  `()` and `\\1`, `\\2`, etc.

Allows you to refer to part of a match by enclosing it in `()`. `\\1`
refers to the first match captured, `\\2` the second, and so on...

```
> strings = c("I want this 5 and this 9 separated by a '-'.")

> gsub(".*([0-9]).*([0-9]).*", "\\1 - \\2", strings)
[1] "5 - 9"
```
---

## Extensions

---
### Non-greedy Matching
    + Problems with greedy matching.
	+ Common simple case, simple solution
	   + Anything except this character
	   + or any of these characters
    + *?
---
### Positive Lookahead and Behind
    + (?=  )   (?<= )
---	
### Negative Lookahead and Behind
    + (?!  )   (?<! )	


---
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>    
  </body>
</html>
